---
git title: "iPhone iPad and Macbook Index Cleaning and Analysis"
author: "Alejandro Tortosa, Sergi Poy"
date: '2023-01-12'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(stringr)
library(dplyr)
library(ggplot2)
```

# Tipologia i cicle de vida de les dades · Pràctica 2
# Neteja i Anàlisi de Dades: iPhone, iPad and Macbook Index
### Alejandro Tortosa Molla i Sergi Poy Garcia

## 1. Descripció del dataset
Utilitzem els datasets que vam extreure a la pràctica anterior, del Iphone Ipad and Macbook Index.
Per a poder realitzar l'Índex haurem de fusionar-los e integrar les dades.
Igual que el Big Mac Index volem tenir una comparativa de paritat de poder adquisitiu pero utilitzant com a referència els products d’Apple, per a poder tenir com a referència també un producte icònic, que no sigui del mercat de la restauració sinó de la tecnología, recordem que Apple representa una part molt important de la venda de mòbils a nivell global amb el seu mòbil insígnia iPhone (https://gs.statcounter.com/vendor-market-share/mobile).

## 2. Integracció i selecció

Per al nostre projecte el que farem serà treballar amb els 3 datasets que vam obtenir en la pràctica anterior:


- average_monthly_salary_index.csv: Aquí tenim el salari mitjà mensual en euros o en dolars i clasificat per país.
- world_currencies.csv: Tenim l’abreviatura de totes les monedes i la seva equivalència en euros o dolars.
- preus_mac_ipad_iphone.csv: Finalment en aquest arxiu tenim totes les dades de tots els models de Macbook, iPad i iPhone amb el seu identificatiu. Tenim a més el país on es ven cada model, així com una columna amb al divisa en la que está el preu de cada dispositiu.

Obtenim així totes les dades importants i representatives a l’hora de voler elaborar l’índex com a objectiu de la pràctica.
Però per a aconseguir l'objectiu les haurem de fusionar en un sol dataset. L'arxiu troncal a partir del qual treballarem és el dels preus_mac_ipad_iphone.csv:

Primer fusionem preus_mac_ipad_iphone.csv amb world_currencies.csv a partir de la columna Currency.
Després fusionem el dataset resultant amb average_monthly_salary_index.csv a partir de la columna Country.

Això però ho farem després de la neteja.


## 3. Neteja de les dades

La neteja de les dades va ítegrament relacionada amb la integració d'aquestes, ja que per a poder-les fusionar amb èxit em de veure que els valors entre columnes coincideixin. Per a més tard quan aquesta integració es faci amb èxit poguem reduir la quantitat de columnes i veure si tenim una cohesió entre elles.



Per tant anem a treballar amb les dades i les carreguem a R:
```{r}
preus_csv <- read.csv("../csv/preus_mac_ipad_iphone.csv")
salaris_csv <- read.csv("../csv/average_monthly_salary_index.csv")
divises_csv <- read.csv("../csv/world_currencies.csv")  
```


La columna de "price" té aquest format: "{'fullPrice': 499990.0}".
Hem d'extreure amb gsub i una RegEx el preu. Com que la columna original es de tipus caràcter (chr) modifiquem amb as.numeric el seu format per obtenir el preu en numèric.
```{r}
class(preus_csv$price)

preus_csv$price <- as.numeric(gsub("[^[:digit:].]", "", preus_csv$price))
head(preus_csv)
```

També hem d'extreure el país de la columna "store" amb una RegEx:

```{r}
# En aquest cas gsub serà suficient per substituir el valor per el coincident amb la RegEx.
preus_csv$store <- gsub("^AOS: (.*) [Consumer|consumer].*$", "\\1", preus_csv$store)
unique(preus_csv$store)
```
Com podem veure pels valors unics el filtratge no ha sortit del tot bé, i no coincideixen amb els equivalents de salaris_csv per a fer una fusió exitosa.
Per exemple de valor tenim "UK" però a salaris_csv tenim "United Kingdom", per tant utilitzarem la funció case_when() per a modificar-los.

Aparentment es un treball tediós però així ens asegurem que les dades estiguin ven integrades i tinguin coherència entre elles. 

```{r}
preus_csv$Country <- case_when(
  preus_csv$store == "German" ~ "Germany",
  preus_csv$store == "Austrian" ~ "Austria",
  preus_csv$store == "Hong Kong Chinese" ~ "Hong Kong",
  preus_csv$store == "Czech" ~ "Czech Republic",
  preus_csv$store == "Korea" ~ "South Korea",
  preus_csv$store == "French Canada" ~ "Canada",
  preus_csv$store == "Finnish" ~ "Finland",
  preus_csv$store == "Irish" ~ "Ireland",
  preus_csv$store == "NZ" ~ "New Zealand",
  preus_csv$store == "US" ~ "United States",
  preus_csv$store == "Belgium French" ~ "Belgium",
  preus_csv$store == "Swedish" ~ "Sweden",
  preus_csv$store == "UAE" ~ "United Arab Emirates",
  preus_csv$store == "Belgium Flemish" ~ "Belgium",
  preus_csv$store == "IN" ~ "India",
  preus_csv$store == "UK" ~ "United Kingdom",
  preus_csv$store == "Swiss French" ~ "Switzerland",
  preus_csv$store == "Italian" ~ "Italy",
  preus_csv$store == "AOS: Apple Store Luxembourg" ~ "Luxembourg",
  preus_csv$store == "Swiss German" ~ "Switzerland",
  preus_csv$store == "French" ~ "France",
  preus_csv$store == "HongKong" ~ "Hong Kong",
  preus_csv$store == "Dutch" ~ "Netherlands",
  TRUE ~ preus_csv$store
  # Amb TRUE ~ preus_csv$store copiem els valors que no hem especificat a la nova columna.
)
head(preus_csv)
```

Donada la neteja anterior fem una fusió dels 3 datasets:
```{r}
# Primer el dataset principal de preus amb el de canvi de divises.
preus_divises_csv <- merge(preus_csv, divises_csv, by.x = "currency", by.y = "Currency")

#Segon el dataset anterior amb el de salaris mensuals mitjans per pais.
apple_index_raw <- merge(preus_divises_csv, salaris_csv, by.x = "Country", by.y = "Country")

head(apple_index_raw)
anyNA(apple_index_raw)
```

El resultat és en principi satisfactori, no tenim valors nuls (si observem el dataset per exemple de average_monthly_salary_index.csv en tenia però s'han perdut en la fusió). 
Veiem però les columnes X1.EUR.in.Currency i X1.USD.in.Currency están en "chr", per tant les hem de transformar:
```{r}
apple_index_raw$X1.EUR.in.Currency <- as.numeric(apple_index_raw$X1.EUR.in.Currency)
apple_index_raw$X1.USD.in.Currency <- as.numeric(apple_index_raw$X1.USD.in.Currency)

unique(apple_index_raw)

```

També tenim moltes columnes que ja no ens fan falta, cóm la de sku, country (la segona) i store. La resta encara poden ser rellevant, per tant eliminem les mencionades:
```{r}
apple_index_raw <- apple_index_raw[, -c(3, 7, 8)]
head(apple_index_raw)
```

Finalment mirarem si tenim valors extrems al dataset i finalitzarem així el procés de neteja i integració.
Principalment evaluarem els valors extrems per veure si la fusió s'ha realitzat amb èxit:
```{r}
# Evaluem els boxplots dels salaris, així veurem si s'ha fusionat bé:
boxplot(apple_index_raw$EUR.Average.Monthly.Salary)
boxplot(apple_index_raw$USD.Average.Monthly.Salary)

boxplot(apple_index_raw$price)


```
Cal dir que en el nostre cas és sencill si coneixem el dataset, 

Amb l'equivalència de l'Euro creem la fòrmula que ens dona els mesos que hem de treballar per a poder comprar un producte Apple en determinat pais.
La fòrmula és:
Preu producte apple / (Sou mitjà mensual * Canvi de divisa a 1€)
```{r}
apple_index_raw$months_to_buy_product <- apple_index_raw$price / (apple_index_raw$EUR.Average.Monthly.Salary * apple_index_raw$X1.EUR.in.Currency)
print(apple_index_raw)
```

Finalment agafem un subset amb només els productes que coincideixen amb el model d'iPhone que volem analitzar i ho plotejem:
```{r}
iphone14PM_index <- subset(apple_index_raw, apple_index_raw$name == "iPhone 14 Pro Max 128GB Silver")


ggplot(iphone14PM_index, aes(x=Country, y=months_to_buy_product)) + 
  geom_bar(stat="identity") +
  xlab("Country") +
  ylab("Months to buy iPhone") +
  ggtitle("Months to buy iPhone 14 Pro Max 128GB Silver by country")
```


